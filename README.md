
# 高频账户余额更新微服务

假设场景专注于高并发的余额更新

使用微服务架构，以应对扩容和容灾的情形， 用户余额微服务
缓存使用 Redis 本地测试使用 Mysql 阿里云使用 PG-SQL，和重试使用 

-- account-balance  账户余额服务
-- common-lib 公共组件，本示例程序没有使用
-- docs  压力测试报告
-- k8s  k8s部署文件（阿里云）
-- deploy.sh  minikube 部署脚步



执行 AccountBalanceApplication.class 本地启动程序


### 悲观锁
我们采用悲观锁，因为读写频繁场景下，乐观锁会给数据库造成额外负担

### SQL批量提交执行
采用 Statement 执行批量语句，让 select .. for update 和具体的 update 语句在同一批次交给数据库执行，减少一次与数据库的交互，提高数据库的响应速度

### 转账操作变为 付款和收款 两个动作
这例子中，我们是单台机器，所以直接执行了两次，在多台机器的时候，收款动作可以根据 hash 值有消息队列交由对应机器处理
在多台机器的场景，收款和付款的用户很可能涉及多个数据库分库执行，如果一次性处理就涉及到分布式锁，可能成为性能瓶颈
将付款和收款分开，通过 Hash 和机器 ID 求余确保同一用户的金额扣减都会在同一机器

### 采用长整数来避免余额精度问题
用户的余额采用 Long 来避免精度问题，100 表示 1 元


## 单元测试

## 性能测试
在本地单机测试的结果是
20 个线程每个线程发 2000 个请求，Ramp-Up 时间 1s 的情况下，
模拟 100 个初始金额 10000 分的用户相互随机转账 1 分的场景，TPS是 1227 (每个请求时间包含写3 条日志的时间，一条转账信息日志，一条付款成功日志，一条收款成功日志)
执行完毕后，用用户总余额不变来验证程序的并发准确性，请求全部成功并能通过准确性检验

本地测试机器参数： Mac2.4GHz 8核心 i9（16-inch 2019 款）32G内存 部署 mysql 和 redis，开启其他很多程序，理论上TPS 在专用服务器可以更高

## 复原力测试
依赖于阿里云 ACK 

